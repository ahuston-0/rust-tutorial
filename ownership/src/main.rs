fn main() {
    strings();
    copy_vars();
    ownership_and_functions();
    return_ownership();
    tuples_and_refs();
    slices();
}

fn strings() {
    // :: works for namespacing, as expected
    let mut s = String::from("test string");
    s.push_str(". Appended string."); // push_str() appends to String
    println!("{}", s);
    // string goes out of scope, can be destroyed (calls drop function to free)
}

fn copy_vars() {
    // Make a copy of x's pointer and place in y
    // They point to the same place
    // Default pass by reference?
    let x = String::from("5");
    let y = x;

    /*
    The borrow checker (understandably) freaks out at this
    `let y = x` moves x to y, which "borrows" x and invalidates
    it until y is released

    Judging from the error generated by the compiler, the Copy trait
    fixes this from the borrow checkers perspective. Kinda strange.

    println!("Hello, {}th.", x);
    */
    println!("Hello, {}th.", y);

    /*
    This is legal because integers have known sizes at compile time
    The difference between copy and move is minimal for these types
    */
    let x_int = 5;
    let y_int = x_int;
    println!("Hello! {} is equal to {}", x_int, y_int);

    // Basically, Copy trait is used on stack objects
    // The Drop trait is used on heap objects
    // Only one can be defined
}

fn ownership_and_functions() {
    let s = String::from("hello"); // x in scope

    takes_ownership(s); // s moves into func, no longer valid here

    let x = 5; // x in scope

    make_copy(x); // x moves into func, but has Copy and so can be reused
} // x, then s go out of scope. s was moved though so it isn't dropped

fn takes_ownership(s: String) {
    // s in scope
    println!("{}", s);
} // s goes out of scope, drop is called, memory is freed

fn make_copy(x: i32) {
    // x in scope
    println!("{}", x);
} // x out of scope, nothing happens since x is copy

fn return_ownership() {
    let _s1 = gives_ownership(); // takes ownership from gives_ownership

    // temporarily loses ownership of string,
    // but takes it back when fn returns
    let _s2 = takes_and_gives_back(String::from("hello"));
}

fn gives_ownership() -> String {
    // moves return to func that calls it

    let s = String::from("Hello"); // s in scope
    s // s returned, moves to caller
}

fn takes_and_gives_back(s: String) -> String {
    // s is returned back to caller scope
    s // s is returned and moves to caller
}

fn tuples_and_refs() {
    let s = String::from("hello"); // s in scope

    // s is moved, but returned as s1, and length given
    let (s1, len) = calc_len(s);
    println!("The length of '{}' is {}", s1, len);

    // Why return unmutable variable to new unmutable variable?
    // Use references instead
    let _len2 = calc_len_ref(&s1); // s is moved then returned
    let s2 = String::from("hello");
    change(&s2); // pass reference to s2
    let mut s3 = String::from("test");
    change_mut(&mut s3); // pass mutable reference to s3
    let _s3 = dangle();
    // I could not make a mutable reference from s3 after this
    // because only one mutable reference of a variable may exist
    // at a time.
    //
    // Mutable borrows also cannot occur while an immutable borrow is
    // occurring.
    // Ex:
    // let r1 = &s3; is fine
    // let r2 = &s3; is fine, as both are immutable
    // let r3 = &mut s3; is not fine, because r1, r2 are used after
    //                   and r3 is a mutable borrow
    // println!("{}, {}, {}", r1, r2, r3); use of all borrows
}

fn calc_len(s: String) -> (String, usize) {
    let length = s.len();
    (s, length) // returns string and length to caller
} // s is not dropped because it is returned

fn calc_len_ref(s: &String) -> usize {
    s.len() // gets length, s is moved back by reference
} // s is not dropped, despite not being returned
  // because its a reference

fn change(s: &String) {
    // This is illegal because references are not mutable by default
    // s.push_str(" appended string");
    println!("We are very much not changing '{}'. Nope, not at all", s)
}

fn change_mut(s: &mut String) {
    println!("We are going to try to change '{}'", s);
    s.push_str(" additional appended string");
    println!("The previous string is now '{}'", s);
}

fn dangle() -> String {
    // dangle returns ref to String
    let s = String::from("Hello"); // s is new string in scope
    s // properly returns ownership of s to caller

    // if we instead return '&s', there would be a dangling reference
    // and s would point at nothing from the caller's perspective because
    // Rust would drop s at the end of this function, since its out of scope
}

fn slices() {
    let mut s = String::from("hello world");

    let word_ind = first_word_ind(&s);
    let word = first_word(&s);
    println!(
        "The first word of '{}' is '{}' at index {}",
        s, word, word_ind,
    );
    s.clear(); // clears s, index is not valid anymore

    // fun fact: string literals are just slices

    let a = [1, 2, 3, 4, 5];
    let slice = &a[1..3]; // looks like its [a,b) for slicing
    assert_eq!(slice, &[2, 3]);
}

// Using &str instead of &String allows the function to
// take both strings and string slices
fn first_word_ind(s: &str) -> usize {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }
    s.len()
}

fn first_word(s: &str) -> &str {
    //&str is string slice
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[..i]; // equivalent to &s[0..i]
        }
    }
    &s[..] // return whole string as slice
}
